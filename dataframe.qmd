# データフレーム

## データフレームとは
ここまでは，Rのベクトル・リストの機能を使って学んできました。
ただ，本格的に社会調査のデータを扱うには，この二つだけでは力不足です。
社会調査の分析では，
さまざまな情報（ID・性別・学力etc）を格納したベクトルを生成し，
それらをまとめて扱う必要があるからです。

ここで必要になるのが，データフレームという機能です。
学力調査の場合，少なくとも次のような変数をまとめて扱う必要があります。

- ID: 生徒一人ひとりの番号。出席番号など
- 成績: 一人ひとりの成績
- 個々人の情報: たとえば性別やアンケートに対する回答など

今，id・成績（score）・性別（gender）という変数が含まれた
仮の学力調査のデータを考えましょう。
簡単のため，idは「1番から7番」，
成績は「50点・55点・60点・65点・70点・欠測・欠測」，
性別は「女子・女子・女子・欠測・男子・男子・男子」とします。
欠測というのは，何らかの理由でたまたまデータが得られなかった箇所のことです。

Rでは，`data.frame`という関数を使ってデータフレームを作成します。
以下の例では，`id`，`score`，`gender`という3つのベクトルを作成し，
その結果を`data.frame`関数で1つにまとめています。

ちなみに欠測の箇所は，999という値を入れています。
これは社会調査の慣例で，欠測には99や999といった
「ありえない」数値を入れることでデータが存在しないことを示しているのです。

```{r}
id <- 1:7 # 出席番号
score <- c(50, 55, 60, 65, 70, 999, 999) # 成績。999は欠測
gender <- c(1, 1, 1, 99, 2, 2, 2) # 性別。1が女子，2が男子

dat <- data.frame(id, score, gender)
```

## データフレームの取り扱い

さて，データフレーム（今回は`dat`というオブジェクト）の扱い方を考えてみましょう。
たとえば`names`関数を使うと，データフレーム内の変数名を知ることができます。
また，`head`関数を使うと，データフレームの上6行の情報を得ることができます。
上から何行の数値がほしいかは，`head`関数の引数に`n = 4`といった形で指定することができます。

```{r}
names(dat)
head(dat)
head(dat, n = 4) # 上から4行を表示
```

データフレーム内の変数にアクセスする場合は，`$`マークを使います。
`dat`の成績（score）が見たい場合は，`dat$score`か`dat[["score"]]`と入力します。
あるいは，成績は前から2列目に格納されているので，`dat[, 2]`としても構いません。
ちなみに`dat[, 2]`はデータフレームの前から2列目を意味します。
`dat[3, ]`とすると3行目ですし，`dat[2, 2]`とすると2行目の2列目の数字（55）が返ってきます[^1]。

[^1]: 行と列がよくわからないという人は，[「行列で縦か横か迷ったら」](https://id.fnshr.info/2015/10/17/matrix/){target="_blank"}をご覧ください。

`dat$score`も`dat[["score"]]`も`dat[, 2]`も同じ情報が返ってきます[^2]。
この中では，`$`を使う方法がもっとも簡単です。
試しに`dat$`と入力してみると，その理由がわかるかもしれません。

[^2]: なぜ同じことをする方法がいくつもあるのかと思う人もいるでしょうが，
  それぞれ異なった使い道があるのです。
  本書では，[Replication Method](replication.qmd)で具体例を示します。

```{r}
dat$score
dat[["score"]]
dat[, 2] # 2列目
dat[3, ] # 3行目
dat[2, 2] # 2列目の2行目（55）
```

データフレーム内の特定の値を修正したいという場合もあるかもしれません。
たとえば，「本当は1人目の成績は40点だったのに間違えて50点と入力してしまった！」といった場合です。
こういう場合は，次のような方法を使います。
まず1人目の成績は，`dat$score[1]`とすることで表示できます。
ここで，`dat$score[1] <- 40`とすると，1人目の成績が40に置き換わります。
ちなみに`dat[2, 2]`のように行と列を指定しても構いません。

```{r}
dat$score[1]
dat$score[1] <- 40
dat$score

dat[2, 2] <- 60 # 2行2列（＝2人目の成績）を指定しても可
dat$score
```

## 欠測値の扱い方

データフレームを作ったら，最初に正しく作成できているかどうか確認したほうがよいでしょう。
たとえば`table`という関数を使うと，ベクトル内の要素を数えることができます。
これを度数分布と呼びます。
度数（データの数）という言葉はよく使うので，覚えておくとよいでしょう。
以下では`table`関数を使って，別変数（gender）の度数分布を作成してみます。

```{r}
dat$gender
table(dat$gender)
```

1が男子・2が女子・99は欠測ですから，
順に3・3・1で適切に入力できているようです。
一方で，成績変数（score）はこのままでは少々問題があります。
たとえば，成績の平均を計算することを考えましょう。
今のままでは，おかしな平均値が算出されてしまいます。

```{r}
dat$score
mean(dat$score)
```

326という平均が出力される理由は，欠測の部分に
999を入力しているからです。
Rは999が欠測ということがわかりませんから，999点だと思って平均を計算してしまい，
数値がおかしくなっているのです。
これを防ぐには，Rにscoreの999は欠測であり，平均を計算するときは省いてほしい旨を
伝える必要があります。

ただ，この処理は少々面倒です。
まず，`dat$score`の999の箇所を特定する必要があります。
ここで[条件を付けて要素にアクセスする](r_basics.qmd#条件を付けて要素にアクセスする)
方法を思い出してみてください。
`dat$score == 999`と入力すれば，`dat$score`というベクトルの中の999の要素の位置を特定できます。
そのため，`dat$score[dat$score == 999]`とすることで999の要素を特定できるのでした。
後は，ここにRで欠測を意味する`NA`という値を格納すれば，
Rにデータに欠測があることを伝えられます。

```{r}
dat$score[dat$score == 999]
dat$score[dat$score == 999] <- NA
dat$score
```

ではもう一回，平均を計算してみましょう。
今度は`NA`になるはずです。欠測が含まれているものに対して平均を計算することはできませんので，
これは当然と言えば当然です。
そこで，欠測の箇所は除いて平均を計算するように伝えます。
これは，`mean`関数の引数に，`na.rm = TRUE`を与えることで実現できます。

```{r}
mean(dat$score)
mean(dat$score, na.rm = TRUE)
```

これでようやく，成績の平均を計算することができました。
ちなみに，男女別の平均を計算することも可能です。
Rでは，`tapply`という関数を使うことで，グループごとに処理が可能です。
`tapply`の引数には，順に「処理したい値」「個々の属するグループ」
「行いたい処理」を与えます。
今回は男女別の成績の平均を計算したいので，順にscore, gender, meanを与えることになります。
欠測を無視するために，最後に`na.rm = TRUE`も与える必要があります。

```{r}
tapply(dat$score, dat$gender, mean, na.rm = TRUE)
```


## LSAのデータファイルを扱う
ここまでは説明のために，自分で作成したデータフレームを使っていました。
しかし実際の分析では，
すでに用意されたデータをデータフレームとして読み込むことが一般的です。

### データの読み込み

以下では，PISA2012の日本のデータをRに読み込むことを考えます。
普通は自分のPCに保存されているデータを使うのですが，
そのためにはフォルダやパスといった概念を知っておく必要があります。
フォルダやパスの説明は少し大変なので，
本書では，私がウェブ上に用意したcsvファイルをRに読み込むことにします。
ここで言うcsvファイルとは，カンマ（,）で項目を区切ったデータのことで，
社会調査ではよく使われます。

Rにcsvファイルを読み込む際は，`read.csv`という関数を使います。
今回はウェブ上にあるcsvファイルを読み込むので，
csvファイルのある場所（url）を`read.csv`の引数に設定します。
読み込んだデータは，`jpn2012`というデータフレームに格納しています。

```{r}
url <- "https://raw.githubusercontent.com/kawa5902/LSAdata/refs/heads/main/pisa2012stuJPN.csv"
jpn2012 <- read.csv(url)
```


### データフレームの確認1

先ほど読み込んだ`jpn2012`の中身を，`names`関数や`head`関数を使って確認してみましょう。
かなりデータファイルが大きいので，ここでは最初の10列だけ表示しています。

```{r}
names(jpn2012)[1:10] # names関数。変数名を出力
head(jpn2012, 10)[, 1:10] # head関数。最初の10人分のデータを出力
```

`$`を使って，個々の変数にアクセスすることも可能です。
たとえば，`ST03Q01`変数（これは生まれ月の変数です）を見てみます。
すべて表示すると数千人分のデータになるので，ここでは最初の12人分だけ表示します。

```{r}
jpn2012$ST03Q01[1:12] # $を使ってデータにアクセス
```

PISA2012は，日本では高校1年生（正確には学校に通う15歳）を対象に実施されています。
高校1年生の生まれ月はどのように分布しているのでしょうか。
`table`関数を使うことで，標本となった人たちの生まれ月の度数分布を確認します。

```{r}
table(jpn2012$ST03Q01)
```

多少のばらつきはありますが，特定の誕生月の子どもが多いということはなさそうに思えます。
パーセント表示にしたほうが見やすいかもしれません。
`table`関数の出力を，`prop.table`関数の引数にすることで割合を表示することができます。
ただ，素の表示は見づらいので100倍して100分率にし，
さらに`round`関数を使って小数桁数を制御したほうがよいでしょう。

```{r}
tb <- table(jpn2012$ST03Q01)
prop.table(tb)
# 100倍する
prop.table(tb) * 100
# round関数で小数桁数を1桁に限定
round(prop.table(tb) * 100, 1)
```

どの生まれ月の人も，だいたい7\%から9\%となっています。
多少の増減はありますが，特定の月が極端に多いということはなさそうです。


さらに，生まれ月を男女別に集計したいということもあるかもしれません。
`table`関数は，複数の引数を設定することで，男女別の集計にも対応できます。
これをクロス集計と呼びます。

```{r}
table(jpn2012$ST04Q01, jpn2012$ST03Q01)
```

パーセント表示がしたいという場合は，先ほどと同じく`prop.table`関数を使います。
引数の1は，横方向に100\%にしてほしいという意味です。
2に設定すると，縦方向に100\%で表示されます。

```{r}
tb <- table(jpn2012$ST04Q01, jpn2012$ST03Q01)
prop.table(tb, 1)
```

こちらも`round`関数に渡すことで桁数を抑制できます。
次の例では数値を100倍したあとに，小数桁数を1桁に設定しています。

```{r}
round(prop.table(tb, 1) * 100, 1)
```

男女によって多少のズレはありますが，女子だから（あるいは男子だから）といって
特定の出生月に偏るといったことはなさそうに思えます。


### データフレームの確認2

続いて，成績の変数も確認してみましょう。
PISAは読解リテラシー・数学リテラシー・科学リテラシーという3領域を調査しています。
ここでは，読解リテラシーの成績が格納された`PV1READ`という変数を見てみます。
PV1が何かは今は気にしなくて構いません
（PVについては，[推算値法](pvs.qmd)の章で扱います）。

最初に，`summary`関数を使って，最大値・最小値・平均値などを確認しましょう。

```{r}
summary(jpn2012$PV1READ)
```

`hist`関数を使うと成績の分布を視覚的に確認することができます。

```{r}
hist(jpn2012$PV1READ, main = "読解リテラシーのヒストグラム", xlab = "スコア", ylab = "度数")
```

場合によっては，読解リテラシーと数学リテラシーの関係を確認したいということもあるでしょう。
この場合は，`plot`という関数が使えます。
ここでは，読解（`PV1READ`）と数学（`PV1MATH`）の関係を見てみましょう。

```{r}
plot(jpn2012$PV1READ, jpn2012$PV1MATH, xlab = "読解リテラシー", ylab = "数学リテラシー")
```

読解リテラシーは男女によって差があるのではないか，と思う人もいるかもしれません。
こういう場合，たとえば箱ひげ図が使えます。
Rでは，`boxplot`という関数を使うことで，箱ひげ図が描けます。

```{r}
boxplot(jpn2012$PV1READ ~ jpn2012$ST04Q01, xlab = "男女（1:女子，2:男子）", ylab = "読解リテラシー")
```

わずかですが，女子のほうが読解リテラシーが高い傾向があるようです。
先ほど紹介した`tapply`関数を使えば，男女の平均値の差を示すことも可能です。

```{r}
tapply(jpn2012$PV1READ, jpn2012$ST04Q01, mean)
```

女子（1）が548.8に対し，男子（2）が527.7点なので，女子のほうが20ポイントほど読解リテラシーが高いようです。

### データフレームの確認3

読み込んだデータに欠測値がある場合も珍しくありません。
たとえばPISA2012のESCSという変数を見てみます。
[ESCS](https://largescaleassessmentsineducation.springeropen.com/articles/10.1186/s40536-020-00086-x){target="_blank"}
はEconomic Social and Cultural Statusの略で，
子どもの家庭環境を示す変数です。
ESCSは，子どもに「お父さんやお母さんの学歴」
「お父さんやお母さんの職業」「家庭のある本の冊数」などを尋ね，
その回答をもとに作成されています。
数値は調査に参加したOECD加盟国の平均が0・標準偏差1に調整されていますので，
0だと平均的な家庭の子ども，2だと相当に恵まれた家庭に育った子ども，
-2だと厳しい状況にある子ども・・・といった解釈ができるでしょう。

さて，PISA2012のESCS変数では9999が欠測値になっています。
お父さんやお母さんの職業・学歴を答えたくないという子もいますから，
欠測があることは珍しいことではありません。
ただ，欠測をそのままにしておくと，平均や標準偏差の計算結果がおかしくなります。
実際，`summary`関数を使うと，中央値と平均値が大きくズレるなど，
おかしなデータになっていることが確認できます。
ヒストグラムを見ても，0付近にほとんどのデータが固まっているのに
10000付近に僅かにデータが存在するなど，変なグラフになってしまいます。

```{r}
summary(jpn2012$ESCS)
hist(jpn2012$ESCS, main = "", xlab = "ESCS", ylab = "度数")
```

このままでは分析に支障がでるので，9999が欠測であることをRに伝えましょう。

```{r}
jpn2012$ESCS[jpn2012$ESCS == 9999] <- NA
```

欠測値をNAに指定すると，`summary`関数や`hist`関数の出力が適切なものに修正されます。

```{r}
summary(jpn2012$ESCS)
hist(jpn2012$ESCS, main = "", xlab = "ESCS", ylab = "度数")
```

読み込んだデータに欠測値がある場合，気づかないまま分析すると誤った結果につながりかねません。
データを読み込んだときは，`table`や`summary`あるいは`hist`といった関数を使い，
おかしなデータが含まれていないか確認する習慣を付けたほうがよいでしょう。
